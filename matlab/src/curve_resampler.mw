%
%
%  This file contains the matlab wrappers 
%  for resampling a curve with a given bandwidth
% 
%
@function [varargout] = resample_curve(xy,nb,eps,nmax)
%
%  This subroutine resamples a given curve whose xy 
%  and attempts to pass a bandlimited curve thorugh them
%
%  Input arguments:
%    xy(2,n) -
%      x,y coordinates of the input points
%    nb - 
%      parameter related to the bandlimit of the curve
%    eps - 
%      (optional) desired accuracy for interpolation of
%      output curve thorugh input points. Default value is
%      1e-12.
%    nmax - 
%      (optional) max number of iterations for attempting
%      to pass bandlimited curve with increasing 
%      storage and computation cost (both these parameters
%      double with with every iterate used). Default value
%      is 4.
%  
%  Output arguemnts:
%    srcinfo(6,nout) - 
%      resampled curve
%    h - 
%      spacing between points in parameter space
%    wsave -
%      (optional, if requested) an array which will
%      allow evaluation of x,y at arbitrary points
%    ts(n) -
%      (optional, if requested) coordinated in parameter
%      space closest to input points
%
%
  [~,n] = size(xy);

  if( nargout < 2 || nargout > 4)
    fprintf('invalid number of output arguments\n');
    fprintf('out arguments must be 2,3 or 4\n');
    vargout(1:nargout) = {0};
    return;
  end

  if (nargin == 2)
    epsuse = 1e-12;
    nmaxuse = 4;
  elseif (nargin == 3)
    epsuse = eps;
    nmaxuse = 4;
  elseif (nargin == 4)
    epsuse = eps;
    nmaxuse = nmax;
  else
    fprintf('invalid number of arguments\n');
  end
  nlarge = n;
  nout = n;
  lused = 0;
  lsave = 0;
  ierm = 0;
  # FORTRAN simple_curve_resampler_mem(int[1] n, double[2,n] xy, int[1] nb, double[1] epsuse, int[1] nmaxuse, inout int[1] nlarge, inout int[1] nout, inout int[1] lsave, inout int[1] lused, inout int[1] ierm);
  if (ierm == 4)
    fprintf('band limit too small\n');
    fprintf('returning without computing anything\n');
    fprintf('run routine again with larger value of nb\n');
    varargout(1:nargout) = {0};
  else if (ierm == 2 && nargin >= 3)
    fprintf('interpolation error not to user specified accuracy\n');
    fprintf('try running the routine by setting nmax > 4\n');
  end

  srcinfo = zeros(6,nout);
  wsave = zeros(lsave,1);
  ts = zeros(n+1,1);
  nn = n+1;
  h = 0.0;
  curvelen = 0.0;
  ier = 0;
  # FORTRAN simple_curve_resampler_guru(int[1] n, double[2,n] xy, int[1] nb, int[1] nlarge, int[1] lsave, int[1] lused, int[1] nout, inout double[6,nout] srcinfo, inout double[1] h, inout double[1] curvelen, inout double[lsave] wsave, inout double[nn] ts, inout int[1] ier);
  varargout{1} = srcinfo;
  varargout{2} = h;

  if(nargout>=3)
    varargout{3} = wsave;
  end

  if(nargout == 4)
    varargout{4} = ts(1:n);
  end

end
%
%
%
%
%
@function [binfo] = eval_curve(ts,wsave)
%
%  This subroutine evaluates the precomputed
%  bandlimited curve generated using resample_curve
%  at a collection of points in parameter space.
%
%  Note it is the user's responsibility to ensure
%  that 0<ts(i)<lenght of curve, otherwise junk
%  values would be returned for ts which do not 
%  satisfy the criterion above
%
%  Input arguments:
%    ts -
%      coordinates where curve needs to be evaluated
%    wsave(1:lsave) -
%      precomputed saved array from resample_curve
%
%  Output arguments:
%    binfo(6,n) -
%      x,y,rnx,rny,dst, curvature at requested points
%
  tsuse = ts(:);
  n = length(tsuse);
  binfo = zeros(6,n);
  lsave = length(wsave);

  #FORTRAN eval_curve_multi(int[1] n, double[n] tsuse, int[1] lsave, double[lsave] wsave, inout double[6,n] binfo);


end
